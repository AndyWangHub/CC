#pragma once

#include<iostream>
#include<string>
#include<exception>
using namespace std;

//自定义的异常类型
class OutOfRange
{
public:
	OutOfRange()
		:m_flag(1),m_len(0),m_index(0){}
	OutOfRange(int len, int index)
		:m_len(len), m_index(index), m_flag(2) {}

	void what() const; //获取具体的错误信息
private:
	int m_flag; //不同的flag表示不同的错误
	int m_len; //当前数组长度
	int m_index; //当前使用的数组下标
};

void OutOfRange::what() const
{
	if (m_flag == 1) {
		cout << "Error: empty array, no elements to pop." << endl;
	}
	else if (m_flag == 2) {
		cout << "Error: out of range( array length " << m_len << ", access index " << m_index << " )" << endl;
	}
	else {
		cout << "Unknown exception." << endl;
	}
}

class Array
{
public:
	Array();
	~Array() { free(m_p); }

	int operator[](int index)const;//获取数组元素
	int push(int ele);//在尾部插入元素
	int pop(); //在尾部删除数组元素
	int length()const { return m_len; } //获取数组长度

private:
	int m_len; //数组长度
	int m_capacity; //当前的内存容纳
	int* m_p;//内存指针
private:
	static const int m_stepSize = 50; //每次扩容的步长
};

Array::Array()
{
	m_p = (int*)malloc(sizeof(int) * m_stepSize);
	m_capacity = m_stepSize;
	m_len = 0;
}

inline int Array::operator[](int index) const
{
	if (index < 0 || index >= m_len) //判断是否越界
	{
		throw OutOfRange(m_len, index);//抛出异常（创建一个匿名对象）
	}
	return *(m_p + index);
}

inline int Array::push(int ele)
{
	if (m_len >= m_capacity) // 如果容量不足就扩容
	{
		m_capacity += m_stepSize; 
		m_p = (int*)realloc(m_p, sizeof(int) * m_capacity);//扩容
	}
	*(m_p + m_len) = ele;
	m_len++;
	return m_len - 1;
}

inline int Array::pop()
{
	if (m_len == 0)
	{
		throw OutOfRange();//抛出异常（创建一个匿名对象）
	}
	m_len--;
	return *(m_p + m_len);
}

//打印数组元素
void printArray(Array& arr)
{
	int len = arr.length();

	//判断数组是否为空
	if (len == 0)
	{
		cout << "Empty array! No elements to print." << endl;
		return;
	}

	for (int i = 0; i < len; i++) 
	{
		if (i == len - 1) {
			cout << arr[i] << endl;
		}
		else {
			cout << arr[i] << ", ";
		}
	}

}

void three()
{
	Array nums;
	//向数组中添加十个元素
	for (size_t i = 0; i < 10; i++)
	{
		nums.push(i);
	}
	printArray(nums);

	//尝试访问第20个元素
	try
	{
		cout << nums[20] << endl;
	}
	catch (const OutOfRange &e)
	{
		e.what();
	}

	//尝试删除20个元素
	try
	{
		for (size_t i = 0; i < 20U; i++)
		{
			nums.pop();
		}
	}
	catch (const OutOfRange& e)
	{
		e.what();
	}

	printArray(nums);
}


